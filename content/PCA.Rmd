---
title: "PCA and DAPC"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# PCA

One important consideration is that we need to deal with linkage in our data set. We will use PCAdapt to help us with this and to illustrate why.

## Load data
First, we load in the data and convert our previous `array.bed` file to pcadapt input
```{r}
library(pcadapt)
filename <- read.pcadapt("../Processed_Data/array.bed", type = "bed")

```

## Examine the PCs
First, we can start with a regular PCA.  The first line of code below calculates the PCA with 5 PCs and the second line plots the amount of variance that each PC explains.

```{r}
res <- pcadapt(filename, K = 5)
plot(res, option = "screeplot")
```

For this analysis, the idea number of PCs is the one before the variance stars plateauing.  Essentially, we're looking for the "elbow."  Here, this would be 2.

Let's plot the PCA.  First, we need to recreate the list of population assignments.  We'll do this the same way as the last section.


```{r, warning=FALSE}
table <- read.table("../Example_Data/strata", header = TRUE)
poplist.names <- table$Population

plot(res, option = "scores", pop = poplist.names)
```

This might look normal, but you'll notice that two of the populations are tightly grouped around PC1.  We should check too make sure this pattern isn't being driven by a linkage in the genome.  To do this, we can look at the loading scores of the PCs.  Loading scores show how much a particular SNP factors into a PC. 


```{r}
par(mfrow = c(2, 2))
for (i in 1:4)
  plot(res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```
These values should be evenly distributed across the genome.  You'll notice that PC1 has a bit of a pattern to it.  Let's zoom in.


```{r}
plot(res$loadings[, 1], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))

```
Now, you can definitely see a weird pattern between Index 30,000 and 40,000.  This is from several large genomic inversion in the oyster genome.  All of those SNPs are highly linked and are driving a large porition of our PCA.

## Dealing with linkage using LD clumping

Linkage Disequilibrium can affect ascertainment of population structure ([Abdellaoui et al. 2013](https://www.nature.com/articles/ejhg201348)). When working with RAD-seq data, it should not be an issue. However, users analyzing dense data such as whole genome sequence data or dense SNP data should account for LD in their genome scans.

Thankfully, PCAdapt has a built in feature that allows us to clump SNPs by LD, basically reducing the data to a more informative subset.
```{r}
res <- pcadapt(filename, K = 10, LD.clumping = list(size = 500, thr = 0.2))
plot(res, option = "screeplot")
```

```{r}
res <- pcadapt(filename, K = 4, LD.clumping = list(size = 500, thr = 0.2))
par(mfrow = c(2, 2))
for (i in 1:4)
  plot(res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```


```{r, warning = FALSE}
plot(res, option = "scores", pop = poplist.names)
```



## Filter data for PCA and DAPC
```{r}
ld_filtered_vcf <- my_vcf[!is.na(res$loadings[,1]),]
mygl <- vcfR2genlight(ld_filtered_vcf,n.cores =2)

strata(mygl) <- strata_df

setPop(mygl) <- ~Population


```

```{r}
oyster.pca <- glPca(mygl, nf = 3)

```


```{r}
barplot(100*oyster.pca$eig/sum(oyster.pca$eig), col = heat.colors(50), main="PCA Variance Explained")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="PC", line = 1)

```


```{r}

myCol <- colorplot(oyster.pca$scores,oyster.pca$scores, transp=TRUE, cex=4)
abline(h=0,v=0, col="grey")
add.scatter.eig(oyster.pca$eig[1:10],2,1,2, posi="bottomright", ratio=.16)
```

```{r}

oyster.pca.df <- as.data.frame(oyster.pca$scores)
oyster.pca.df$pop <- pop(mygl)
cols <-c("#871a1a","#33A02C","#1F78B4")

p <- ggplot(oyster.pca.df, aes(x=PC1, y=PC2, colour=pop)) 
p <- p + geom_point(size=2)
p <- p + stat_ellipse(level = 0.95, size = 1)
p <- p + scale_color_manual(values = cols) 
p <- p + geom_hline(yintercept = 0) 
p <- p + geom_vline(xintercept = 0) 
p <- p + theme_bw()

p
```

```{r}
grp <- find.clusters(mygl, max.n.clust=10)
table(pop(mygl), grp$grp)
```

```{r}
oyster.dapc <- dapc(mygl, n.pca = 3, n.da = 2, grp$grp)
scatter(oyster.dapc,col=cols,bg="white", solid=1)
```

```{r}
compoplot(oyster.dapc, posi="bottom",txt.leg=paste("Cluster", 1:6), lab="", ncol=1, xlab="individuals")
```

```{r}
```

```{r}
oyster.dapc <- dapc(mygl, n.pca = 3, n.da = 2)
scatter(oyster.dapc, col = cols, cex = 2, legend = TRUE, clabel = F, posi.leg = "bottomleft", scree.pca = TRUE,
        posi.pca = "topleft", cleg = 0.75, posi.da = "topright")
```

```{r}
compoplot(oyster.dapc, posi="bottom",txt.leg=paste("Cluster", 1:3), lab="", ncol=1, xlab="individuals")
```
```{r}
dapc.df <- as.data.frame(oyster.dapc$posterior)
dapc.df$pop <- pop(mygl)
dapc.df$indNames <- rownames(dapc.df)

library(tidyr)
dapc.df <- pivot_longer(dapc.df, -c(pop, indNames))
colnames(dapc.df) <- c("Original_Pop","Sample","Assigned_Pop","Posterior_membership_probability")

p <- ggplot(dapc.df, aes(x=Sample, y=Posterior_membership_probability, fill=Assigned_Pop))
p <- p + geom_bar(stat='identity') 
p <- p + scale_fill_manual(values = cols) 
p <- p + facet_grid(~Original_Pop, scales = "free")
p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8))
p <- p + ylab("Posterior membership probability")
p
```



```{r}
adegenetServer(what = "DAPC")
```

